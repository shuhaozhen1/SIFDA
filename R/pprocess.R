generate_random_process_values <- function(time_points, meanf=function(x){0},
                                           covariancef, num_basis=1000, distribution = "normal") {

  # Calculate the covariance matrix between each pair of time points
  covariance_matrix <- outer(time_points, time_points, covariancef)

  # Decompose the covariance matrix into eigenvectors and eigenvalues
  eigen <- eigen(covariance_matrix)

  # Determine the number of basis functions to use for approximation
  # If the requested number of basis functions is greater than the number of eigenvectors, use all eigenvectors instead
  num_basis <- min(num_basis, ncol(eigen$vectors))

  # Select the first `num_basis` eigenvectors as the basis functions
  basis_functions <- eigen$vectors[, 1:num_basis]
  eigen_values <- eigen$values[1:num_basis]

  # Generate weights for the basis functions
  # The distribution for generating the weights can be specified using the `distribution` argument
  if (distribution == "normal") {
    weights <- rnorm(num_basis)
  } else if (distribution == "uniform") {
    weights <- runif(num_basis)
  } else if (distribution == "exponential") {
    weights <- rexp(num_basis)-1
  } else {
    stop("Invalid distribution argument. Choose 'normal', 'uniform', or 'exponential'.")
  }

  # Scale the weights by the square root of the eigenvalues
  weights <-  t(sqrt(diag(eigen_values)) %*% weights)

  # Calculate the values of the random process at each time point
  # by taking the inner product between the weights and the basis functions
  process_values_matrix <- weights %*% t(basis_functions)
  process_values_matrix <- t(process_values_matrix) + meanf(time_points)

  # Return the matrix of random process values
  return(cbind(time_points, process_values_matrix))
}


pprocess_tp <- function(time_points, mean_list, cov_list, n_b = 1000, dis_vector = NULL, covmatrix = NULL) {

  # Check input arguments
  p <- length(mean_list)
  if (is.null(dis_vector)) {
    dis_vector <- rep('normal', p)
  }
  if (is.null(covmatrix)) {
    covmatrix <- diag(rep(1, p))
  }

  # Generate process values
  x <- matrix(0, nrow = length(time_points), ncol = p)
  for (i in 1:p) {
    x[, i] <- generate_random_process_values(time_points = time_points, meanf = mean_list[[i]],
                                             covariancef = cov_list[[i]],
                                             num_basis = n_b, distribution = dis_vector[i])[, 2]
  }

  # Transform process values using covariance matrix
  trans_x <- t(covmatrix %*% t(x))

  # Return time points and transformed process values
  return(cbind(t = time_points, xp = trans_x))
}


#' @title Generate random functional data
#'
#' @description This function generates random functional data with error. The data is generated by simulating a set of functional
#' observations for each of the n elements, which are assumed to have the same number of time points m. The function
#' generates a list of length n with each element of the list corresponding to a set of functional observations.
#'
#' @param n The number of elements to generate
#' @param m The number of time points for each element
#' @param mean_list A list of length p containing mean functions for each of the p processes
#' @param cov_list A list of length p containing covariance functions for each of the p processes
#' @param dis_vector A vector of length p specifying the distribution to use for each of the p processes. If NULL,
#'   'normal' distribution will be used for all processes.
#' @param covmatrix A p x p covariance matrix to be used when generating correlated processes. If NULL, an
#'   identity matrix will be used.
#' @param sig The standard deviation of the error to add to the generated functional data
#' @param depend A boolean indicating whether to generate data with dependent errors or not
#' @param domain A vector of length 2 specifying the domain of the time points
#'
#' @return A list of length n, where each element is a matrix with the generated functional data. The matrix
#'   has nrow = m_i (the number of time points for the element) and ncol = p + 1 (the number of processes plus
#'   time points). The first column contains the time points and the remaining columns contain the functional
#'   observations.
#'
#' @examples
#' # Generate random functional data with 10 elements, 20 time points for each element, 2 processes,
#' # mean functions (x+1)^2 and (x-1)^2, and covariance functions exp(-|x-y|) and exp(-2*|x-y|).
#' # The data will have independent errors with standard deviation 0.1.
#' rp_generate(n=10, m=20, mean_list=list(function(x) (x+1)^2, function(x) (x-1)^2),
#'             cov_list=list(function(x,y) exp(-abs(x-y)), function(x,y) exp(-2*abs(x-y))),
#'             sig=0.1)
#'
#' @export
rp_generate <- function(n,m,mean_list,cov_list,dis_vector=NULL,covmatrix=NULL,sig=0.1,depend=F, domain=c(0,1)){
  generate_time_points <- function(n, m, domain = c(0,1)) {
    # Generate a list to store the time points for each element
    time_points_list <- list()

    for (i in 1:n) {
      # Sample the number of time points for the i-th element from (m-1, m, m+1)
      m_i <- sample(c(m-1, m, m+1), 1)

      # Generate m_i time points uniformly distributed from 0 to 1
      time_points_i <- sort(runif(m_i, min = domain[1], max = domain[2]))

      # Add the time points for the i-th element to the list
      time_points_list[[i]] <- time_points_i
    }

    # Return the list of time points
    return(time_points_list)
  }

  t_list <- generate_time_points(n=n,m=m, domain = domain)

  p_list <- lapply(t_list, pprocess_tp, mean_list=mean_list, cov_list=cov_list,dis_vector=dis_vector,
                         covmatrix=covmatrix)


  if(depend == F){
    p_error <- lapply(p_list, function(x){
      x[,-1] <- x[,-1] + rnorm(n=nrow(x), sd= sig)
      return(x)
      })
  } else {
    p_error <- lapply(p_list, function(x){
      x[,-1] <- x[,-1] + rnorm(1, sd= sig) * x[,2]
      return(x)
    })
  }

  return(p_error)
}

#' @title Generate data with a varying coefficient model
#'
#' @description  This function generates simulated longitudinal data with a varying coefficient model.
#'
#' @param n Number of subjects.
#' @param m Number of time points for each subject.
#' @param coef_list A list of functions defining the varying coefficients for each covariate.
#' @param mean_list A list of means for the multivariate normal distribution used to generate the random effects.
#' @param cov_list A list of covariance matrices for the multivariate normal distribution used to generate the random effects.
#' @param dis_vector A vector of covariate values for each subject, defaults to NULL.
#' @param covmatrix A covariance matrix for the covariates, defaults to NULL.
#' @param sig Standard deviation of the error term, defaults to 0.1.
#' @param depend A logical indicating whether the error term is dependent on the outcome, defaults to FALSE.
#' @param domain A vector specifying the domain of the time points, defaults to c(0,1).
#'
#' @return A list of matrices representing the generated longitudinal data.
#' Each matrix has m columns, where the first column represents time and the remaining columns represent covariates and outcomes.
#' Each row represents an observation for a single subject at a single time point.
#'
#' @examples
#' n <- 50
#' m <- 10
#' coef_list <- list(function(x){x^2}, function(x){sin(pi*x)}, function(x){cos(pi*x)})
#' mean_list <- c(0,0,0)
#' cov_list <- list(diag(3),diag(3),diag(3))
#' dis_vector <- runif(n*3,0,1)
#' rp_VCM_generate(n=n, m=m, coef_list=coef_list, mean_list=mean_list, cov_list=cov_list, dis_vector=dis_vector)
#'
#' @export
rp_VCM_generate <- function(n,m,coef_list, mean_list,cov_list,dis_vector=NULL,
                            covmatrix=NULL,sig=0.1,depend=F, domain=c(0,1)){
  generate_time_points <- function(n, m, domain = c(0,1)) {
    # Generate a list to store the time points for each element
    time_points_list <- list()

    for (i in 1:n) {
      # Sample the number of time points for the i-th element from (m-1, m, m+1)
      m_i <- sample(c(m-1, m, m+1), 1)

      # Generate m_i time points uniformly distributed from 0 to 1
      time_points_i <- sort(runif(m_i, min = domain[1], max = domain[2]))

      # Add the time points for the i-th element to the list
      time_points_list[[i]] <- time_points_i
    }

    # Return the list of time points
    return(time_points_list)
  }

  t_list <- generate_time_points(n=n,m=m, domain = domain)

  p_list <- lapply(t_list, pprocess_tp, mean_list=mean_list, cov_list=cov_list,dis_vector=dis_vector,
                   covmatrix=covmatrix)

  for(i in 1:n) {
    beta <- sapply(coef_list, function(x){x(p_list[[i]][,1])})
    yi <-  rowSums( p_list[[i]][,-1] * beta )
    p_list[[i]] <- cbind(p_list[[i]],yi)
  }

  if(depend == F){
    p_error <- lapply(p_list, function(x){
      x[,ncol(x)] <- x[,ncol(x)] + rnorm(n=nrow(x), sd= sig)
      return(x)
    })
  } else {
    p_error <- lapply(p_list, function(x){
      x[,ncol(x)] <- x[,ncol(x)] + rnorm(1, sd= sig) * x[,ncol(x)]/length(mean_list)
      return(x)
    })
  }

  return(p_error)
}


